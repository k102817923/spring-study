<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p ="http://www.springframework.org/schema/p"
       xmlns:c="http://www.springframework.org/schema/c"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd"
>

    <!-- 使用 Spring 来创建对象，这些都称为 Bean
         类型 变量名 = new 类型()
         Hello hello = new Hello()

         id = 变量名
         class = new 的对象
         property = 给对象中的属性设置值
    -->
    <!--
        IOC 控制反转
        控制: 谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用 Spring 后，对象是由 Spring 来创建的
        反转: 程序本身不创建对象，而变成被动的接收对象
        依赖注入: 利用 set() 来进行注入
        IOC 是一种编程思想，由主动的编程编程被动的接收
    -->
    <bean id="hello" class="com.spring.pojo.Hello">
        <property name="title" value="World"/>
    </bean>

<!--    &lt;!&ndash;-->
<!--        value: 具体的值，基本数据类型-->
<!--        ref: 引用 Spring 容器中创建好的对象-->
<!--    &ndash;&gt;-->
    <bean id = "mysqlImpl" class="com.spring.dao.UserDaoMysqlImpl"/>
    <bean id="userServiceImpl" class="com.spring.service.UserServiceImpl">
        <property name="userDao" ref="mysqlImpl"/>
    </bean>

    <bean id="beforeLog" class="com.spring.log.BeforeLog"/>
    <bean id="afterLog" class="com.spring.log.AfterLog"/>

    <!-- aop 的配置 -->
    <!-- 方式一：使用原生 Spring API 接口 -->
    <!-- 需要导入 aop 的约束 -->
<!--    <aop:config>-->
<!--        &lt;!&ndash; 切入点 expression：表达式匹配要执行的方法 &ndash;&gt;-->
<!--        &lt;!&ndash;-->
<!--            execution (* com.sample.service.impl..*.*(..))-->
<!--            execution()：表达式主体-->
<!--            第一个 * 号：表示返回类型，* 号表示所有的类型-->
<!--            包名：表示需要拦截的包名，后面的两个句点分别表示当前包和当前包的所有子包，com.sample.service.impl 包、子孙包下所有类的方法-->
<!--            第二个 * 号：表示类名，* 号表示所有的类-->
<!--            *(..) ：第三个星号表示方法名，* 号表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数-->
<!--        &ndash;&gt;-->
<!--        <aop:pointcut id="pointcut" expression="execution(* com.spring.service.UserServiceImpl.*(..))"/>-->
<!--        &lt;!&ndash; 执行环绕 advice-ref：执行方法 pointcut-ref：切入点 &ndash;&gt;-->
<!--        <aop:advisor advice-ref="beforeLog" pointcut-ref="pointcut"/>-->
<!--        <aop:advisor advice-ref="afterLog" pointcut-ref="pointcut"/>-->
<!--    </aop:config>-->

    <!-- 方式二：自定义类 -->
<!--    <bean id="diy" class="com.spring.diy.DiyPointcut"/>-->
<!--    <aop:config>-->
<!--        &lt;!&ndash; 自定义切面，ref：要引用的类 &ndash;&gt;-->
<!--        <aop:aspect ref="diy">-->
<!--            &lt;!&ndash; 切入点 &ndash;&gt;-->
<!--            <aop:pointcut id="diyPointcut" expression="execution(* com.spring.service.UserServiceImpl.*(..))"/>-->
<!--            &lt;!&ndash; 通知 &ndash;&gt;-->
<!--            <aop:before method="before" pointcut-ref="diyPointcut"/>-->
<!--            <aop:after method="after" pointcut-ref="diyPointcut"/>-->
<!--        </aop:aspect>-->
<!--    </aop:config>-->

    <!-- 方式三：注解实现-->
    <bean id="annotationPointcut" class="com.spring.diy.AnnotationPointcut"/>
    <!-- 开启注解支持 -->
    <!--
        通过 aop 命名空间的 <aop:aspectj-autoproxy/> 声明自动为 Spring 容器中那些配置 @aspectJ 切面的 bean 创建代理，织入切面
        当然，Spring 在内部依旧采用 AnnotationAwareAspectJAutoProxyCreator 进行自动代理的创建工作，但具体实现的细节已经被 <aop:aspectj-autoproxy/> 隐藏起来了
        <aop:aspectj-autoproxy/> 有一个 proxy-target-class 属性，默认为 false，表示使用 jdk 动态代理织入增强，当配置为 <aop:aspectj-autoproxy poxy-target-class="true"/> 时，表示使用 CGLib 动态代理技术织入增强
        不过即使 proxy-target-class 设置为 false，如果目标类没有声明接口，则 Spring 将自动使用 CGLib 动态代理
    -->
    <aop:aspectj-autoproxy/>

    <!-- 默认使用无参构造创建对象 -->
<!--    <bean id="user" class="com.spring.pojo.User"/>-->

    <!-- 有参构造使用下列三种方式 -->
<!--    <bean id="user" class="com.spring.pojo.User">-->
<!--        <constructor-arg index="0" value="下标赋值"/>-->
<!--    </bean>-->

<!--    <bean id="user" class="com.spring.pojo.User">-->
<!--        <constructor-arg type="java.lang.String" value="类型赋值，不推荐"/>-->
<!--    </bean>-->

    <!--
        id 是 bean 的唯一标识符，如果没有配置 id，那么 name 就是默认标识符
        如果配置了 id，又配置了 name，那么 name 是别名
        name 可以设置多个别名，可以用逗号、分好、空格隔开
        如果不配置 id 和 name，可以根据 applicationContext.getBean(.class) 获取对象
        class 是 bean 的全限定名 = 包名 + 类名
    -->
    <!-- 设置别名: 在获取 bean 的时候可以使用别名获取 -->
<!--    <alias name="user" alias="userT"/>-->
<!--    <bean id="user" name="user_alias user_alias2,user_alias3;user_alias4" class="com.spring.pojo.User">-->
<!--        <constructor-arg name="name" value="参数名赋值"/>-->
<!--    </bean>-->

    <!--
        P 命名空间注入：需要在头文件中加入约束文件sc
        P(属性：properties)命名空间，属性依然要设置 set 方法
    -->
<!--    <bean id="user" class="com.spring.pojo.User" p:name="P 命名空间注入"/>-->

    <!--
        C 命名空间注入：需要在头文件中加入约束文件
        C(构造：Constructor)命名空间，属性依然要设置 set 方法
        需要设置有参构造
    -->
<!--    <bean id="user" class="com.spring.pojo.User" c:name="C 命名空间注入"/>-->

    <!--
        Bean 作用域
        在 Spring 中，那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，都称之为 Bean，即 Bean 就是由 IOC 容器初始化、装配、管理的对象
        Singleton：在 Spring IOC 容器中仅存在一个 Bean 实例，Bean 以单例模式存在，默认值
        prototype：每次从容器中调用 Bean 时，都返回一个新实例，即每次调用 getBean() 时相当于执行 new xxxBean()
        request：每次 HTTP 请求都会创建一个 Bean，该作用域仅适用于 WebApplicationContext 环境
        session：同一个 HTTP Session 共享一个 Bean，不同 Session 使用不同 Bean，仅适用于 WebApplicationContext 环境
    -->
<!--    <bean id="user" class="com.spring.pojo.User" scope="singleton"/>-->



    <!-- 开启注解支持 -->
    <context:annotation-config/>

    <!-- 配置扫描哪些包下的注解 -->
    <!--
        为了更好的分层，Spring 可以使用其他三个注解，功能一样，写上这些注解，即将这个类交给 Spring 管理装配
        @Controller：web 层
        @Service：service 层
        @Repository：dao 层
    -->
    <context:component-scan base-package="com.spring"/>

    <!--
        当一个 bean 节点带有 autowire byName 属性时，将查找其类中所有的 set 方法，例如 setCat()，匹配将 set 去除并设置首字母小写的字符串，即 cat
        Spring 容器中如果存在此字符串名称 ID 的对象，则取出并注入，如果不存在则报空指针异常
    -->
<!--    <bean id="user" class="com.spring.pojo.User" autowire="byName">-->
<!--        <property name="name" value="Bean 的按名称自动装配"/>-->
<!--    </bean>-->

    <!--
        同一类型的对象，在 Spring 容器中需保证唯一，否则会报错 NoUniqueBeanDefinitionException
        按类型匹配，bean 的名称写错或者 ID 属性去除也不影响
    -->
<!--    <bean id="user" class="com.spring.pojo.User" autowire="byType">-->
<!--        <property name="name" value="Bean 的按类型自动装配"/>-->
<!--    </bean>-->

</beans>